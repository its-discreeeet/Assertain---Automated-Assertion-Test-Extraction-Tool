Q1. How many assertions did you find in each project?
Ans. I used 3 repositories for the evaluation of my tool, the assertions found in each were as follows :-

- pytest :- 5140 assertions (https://github.com/pytest-dev/pytest)
- flask :- 999 assertions (https://github.com/pallets/flask)
- requests :- 587 assertions (https://github.com/psf/requests)

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>------------------------------------------<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

Q2. What did you do to validate if the tool is correct?
Ans. For this i applied a simple approach of creating a small set of test files with known assertions (involving assert statements and assertion methods). 

For eg :-
                                    import unittest

                                    # Base test class with common assertions
                                    class BaseTest(unittest.TestCase):
                                        def assert_positive(self, value):
                                            self.assertGreater(value, 0, "Value is not positive")

                                    # Derived test class inheriting from BaseTest
                                    class TestMath(BaseTest):
                                        def test_addition(self):
                                            result = 1 + 1
                                            assert result == 2, "Plain assert failed"

                                        def test_positive_number(self):
                                            self.assert_positive(5)  # Assertion method from BaseTest

                                    # Another derived class adding more tests
                                    class AdvancedTest(TestMath):
                                        def test_multiplication(self):
                                            self.assertTrue(2 * 3 == 6, "AssertTrue failed")


I ran my tool on such small code files to validate the answers. The reason for going with this approach was because i found it simple and reliable. 
NOTE : This is just a simple example for the sake of explanation. I used multiple such sample files with varying complexities.

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>------------------------------------------<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

Q3. What are the limitations? For example, does your tool miss assertions? 
Ans. The limitations that i spotted in my tool so far are :-

- Only performs static analysis : Using ast module, only the static analysis of the code can be performed, but the assertions that are generated during the runtime may be overlooked

- Unconventional naming : My tool relies on the programmers to follow standard naming patterns like using keywords like assert, self.assertEqual. So in case, such conventions are not followed, the tool will not detect those assertion statements. .

- Functional calls from other files : I realized that if a test file calls a function defined in another file that contains assertions, those assertions wonâ€™t be detected.
                            For eg.
                                    > baz.py
                                    def check_length(text):
                                        assert len(text) > 5, "Text is too short"

                                    > test_baz.py
                                    from baz import check_length

                                    def test_check_length():
                                        check_length("This is a test string")

In this my tool will miss out on the assertion in baz.py


All in all, these were some of the limitations i found, there may or may not be more.

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>------------------------------------------<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

Q4. What were the key challenges that you faced in your implementation?
Ans. This task was a fun one but definitely came with its own set of challenges. Testing is a relatively new field for me. I enjoyed learning and exploring about it. Here are the challenges i faced were :-

- Initially everything seemed pretty daunting as i had never heard of a lot of these terms before, so most of my initial time went in just studying and learning about these concepts. Getting familiar with the way things were approached in testing, the conventions used and the different python modules used for this, took me time to learn. However, getting a good grip on these made things easier along the way.

- Tackling inheritance was another challenge. This might not seem that big of a deal i agree, but coming up with the logic of dealing with this was not as simple as it looks. I was using the ast node visitor but whenever it came across sub classes, my logic was failing.I spent sometime on this just to realize a simple addition of one line of code can make the difference. Here's how

Code snippet of class visitor :- 
            def visit_ClassDef(self, node):
                old_class = self.current_class
                self.current_class = node.name
                self.generic_visit(node)
                self.current_class = old_class

adding the line "old_class = self.current_class" helped solve the problem. Whenever the class visitor enters a class, it stores the initial class in old_class variable, so that even if it enters a sub-class, the context of the parent class is stil retrieved. Thus while associating the assertion to the respective class, the context is utilized. Same logic was used in function visitor too. 


- Handling framework specific assertions : Handling framework-specific assertion mechanisms, such as pytest.raises in pytest and methods like self.assertEqual in unittest and a few more was a challenge. These constructs are not just basic assert statements, they were also widely used in test files, and my initial implementation did not account for them. As a result, the tool missed assertions in tests that relied on these framework-specific mechanisms. 

To overcome this however, I added logic to identify calls to pytest.raises by analyzing the ast.Attribute and ast.Name nodes. If the function call matches pytest.raises, I record it as an assertion. For self.assertEqual, self.assertTrue, I checked if the method name starts with assert or Assert as they are commonly used in unittest-style tests. This significantly improved my tool's ability to handle a variety of assertion mechanisms from several testing frameworks.

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>------------------------------------------<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

To conclude, this was an enjoyable experience for me. I am grateful to Dr. Marcelo d'Amorim for shortlisting me for this opportunity. I learnt a lot of things from this and I am really looking forward to learning and working on other exciting projects like this.


Regards,
Kaustubh Patil
